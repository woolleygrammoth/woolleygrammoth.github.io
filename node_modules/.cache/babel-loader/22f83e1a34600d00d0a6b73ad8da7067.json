{"ast":null,"code":"/**\n * @fileoverview Strengthen the ability of file system\n * @author wliao <wliao@Ctrip.com> \n */\nvar fs = require('fs');\n\nvar util = require('utils-extend');\n\nvar path = require('path');\n\nvar fileMatch = require('file-match');\n\nfunction checkCbAndOpts(options, callback) {\n  if (util.isFunction(options)) {\n    return {\n      options: null,\n      callback: options\n    };\n  } else if (util.isObject(options)) {\n    return {\n      options: options,\n      callback: callback\n    };\n  } else {\n    return {\n      options: null,\n      callback: util.noop\n    };\n  }\n}\n\nfunction getExists(filepath) {\n  var exists = fs.existsSync(filepath);\n\n  if (exists) {\n    return filepath;\n  } else {\n    return getExists(path.dirname(filepath));\n  }\n}\n\nutil.extend(exports, fs);\n/**\n * @description\n * Assign node origin methods to fs\n */\n\nexports.fs = fs;\nexports.fileMatch = fileMatch;\n/**\n * @description\n * Create dir, if dir exist, it will only invoke callback.\n *\n * @example\n * ```js\n *   fs.mkdir('1/2/3/4/5', 511);\n *   fs.mkdir('path/2/3', function() {});\n * ```\n */\n\nexports.mkdir = function (filepath, mode, callback) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n\n  if (util.isFunction(mode)) {\n    callback = mode;\n    mode = null;\n  }\n\n  if (!util.isFunction(callback)) {\n    callback = util.noop;\n  }\n\n  mode = mode || 511;\n  if (!children) return callback();\n  children = children.split(path.sep);\n\n  function create(filepath) {\n    if (create.count === children.length) {\n      return callback();\n    }\n\n    filepath = path.join(filepath, children[create.count]);\n    fs.mkdir(filepath, mode, function (err) {\n      create.count++;\n      create(filepath);\n    });\n  }\n\n  create.count = 0;\n  create(root);\n};\n/**\n * @description\n * Same as mkdir, but it is synchronous\n */\n\n\nexports.mkdirSync = function (filepath, mode) {\n  var root = getExists(filepath);\n  var children = path.relative(root, filepath);\n  if (!children) return;\n  children = children.split(path.sep);\n  children.forEach(function (item) {\n    root = path.join(root, item);\n    fs.mkdirSync(root, mode);\n  });\n};\n/**\n * @description \n * Create file, if path don't exists, it will not throw error.\n * And will mkdir for path, it is asynchronous\n * \n * @example\n * ```js\n *   fs.writeFile('path/filename.txt', 'something')\n *   fs.writeFile('path/filename.txt', 'something', {})\n * ```\n */\n\n\nexports.writeFile = function (filename, data, options, callback) {\n  var result = checkCbAndOpts(options, callback);\n  var dirname = path.dirname(filename);\n  options = result.options;\n  callback = result.callback; // Create dir first\n\n  exports.mkdir(dirname, function () {\n    fs.writeFile(filename, data, options, callback);\n  });\n};\n/**\n * @description\n * Same as writeFile, but it is synchronous\n */\n\n\nexports.writeFileSync = function (filename, data, options) {\n  var dirname = path.dirname(filename);\n  exports.mkdirSync(dirname);\n  fs.writeFileSync(filename, data, options);\n};\n/**\n * @description\n * Asynchronously copy a file\n * @example\n * file.copyFile('demo.txt', 'demo.dest.txt', { done: function(err) { }})\n */\n\n\nexports.copyFile = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    done: util.noop\n  }, options || {});\n\n  if (!options.process) {\n    options.encoding = null;\n  }\n\n  fs.readFile(srcpath, {\n    encoding: options.encoding\n  }, function (err, contents) {\n    if (err) return options.done(err);\n\n    if (options.process) {\n      contents = options.process(contents);\n    }\n\n    exports.writeFile(destpath, contents, options, options.done);\n  });\n};\n/**\n * @description\n * Copy file to dest, if no process options, it will only copy file to dest\n * @example\n * file.copyFileSync('demo.txt', 'demo.dest.txt' { process: function(contents) { }});\n * file.copyFileSync('demo.png', 'dest.png');\n */\n\n\nexports.copyFileSync = function (srcpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8'\n  }, options || {});\n  var contents;\n\n  if (options.process) {\n    contents = fs.readFileSync(srcpath, options);\n    contents = options.process(contents, srcpath, options.relative);\n\n    if (util.isObject(contents) && contents.filepath) {\n      destpath = contents.filepath;\n      contents = contents.contents;\n    }\n\n    exports.writeFileSync(destpath, contents, options);\n  } else {\n    contents = fs.readFileSync(srcpath);\n    exports.writeFileSync(destpath, contents);\n  }\n};\n/**\n * @description\n * Recurse into a directory, executing callback for each file and folder\n * if the filename is undefiend, the callback is for folder, otherwise for file.\n * and it is asynchronous\n * @example\n * file.recurse('path', function(filepath, filename) { });\n * file.recurse('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) { });\n */\n\n\nexports.recurse = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdir(dirpath, function (err, files) {\n      if (err) return callback(err);\n      files.forEach(function (filename) {\n        var filepath = path.join(dirpath, filename);\n        fs.stat(filepath, function (err, stats) {\n          var relative = path.relative(rootpath, filepath);\n          var flag = filterCb(relative);\n\n          if (stats.isDirectory()) {\n            recurse(filepath);\n            if (flag) callback(filepath, relative);\n          } else {\n            if (flag) callback(filepath, relative, filename);\n          }\n        });\n      });\n    });\n  }\n\n  recurse(dirpath);\n};\n/**\n * @description\n * Same as recurse, but it is synchronous\n * @example\n * file.recurseSync('path', function(filepath, filename) {});\n * file.recurseSync('path', ['*.js', 'path/**\\/*.html'], function(filepath, relative, filename) {});\n */\n\n\nexports.recurseSync = function (dirpath, filter, callback) {\n  if (util.isFunction(filter)) {\n    callback = filter;\n    filter = null;\n  }\n\n  var filterCb = fileMatch(filter);\n  var rootpath = dirpath;\n\n  function recurse(dirpath) {\n    fs.readdirSync(dirpath).forEach(function (filename) {\n      var filepath = path.join(dirpath, filename);\n      var stats = fs.statSync(filepath);\n      var relative = path.relative(rootpath, filepath);\n      var flag = filterCb(relative);\n\n      if (stats.isDirectory()) {\n        recurse(filepath);\n        if (flag) callback(filepath, relative);\n      } else {\n        if (flag) callback(filepath, relative, filename);\n      }\n    });\n  }\n\n  recurse(dirpath);\n};\n/**\n * @description\n * Remove folder and files in folder, but it's synchronous\n * @example\n * file.rmdirSync('path');\n */\n\n\nexports.rmdirSync = function (dirpath) {\n  exports.recurseSync(dirpath, function (filepath, relative, filename) {\n    // it is file, otherwise it's folder\n    if (filename) {\n      fs.unlinkSync(filepath);\n    } else {\n      fs.rmdirSync(filepath);\n    }\n  });\n  fs.rmdirSync(dirpath);\n};\n/**\n * @description\n * Copy dirpath to destpath, pass process callback for each file hanlder\n * if you want to change the dest filepath, process callback return { contents: '', filepath: ''}\n * otherwise only change contents\n * @example\n * file.copySync('path', 'dest');\n * file.copySync('src', 'dest/src');\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} });\n * file.copySync('path', 'dest', { process: function(contents, filepath) {} }, noProcess: ['']);\n */\n\n\nexports.copySync = function (dirpath, destpath, options) {\n  options = util.extend({\n    encoding: 'utf8',\n    filter: null,\n    noProcess: ''\n  }, options || {});\n  var noProcessCb = fileMatch(options.noProcess); // Make sure dest root\n\n  exports.mkdirSync(destpath);\n  exports.recurseSync(dirpath, options.filter, function (filepath, relative, filename) {\n    if (!filename) return;\n    var newpath = path.join(destpath, relative);\n    var opts = {\n      relative: relative\n    };\n\n    if (options.process && !noProcessCb(relative)) {\n      opts.encoding = options.encoding;\n      opts.process = options.process;\n    }\n\n    exports.copyFileSync(filepath, newpath, opts);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}